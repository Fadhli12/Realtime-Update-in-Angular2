{
  "name": "Realtime Update in Angular2",
  "tagline": "This blog discusses realtime update in Angular2.",
  "body": "# Realtime Update in Angular2\r\n\r\nMany a time we encounter a situation when we need to update our view **real time**. By **real time** I mean that as soon as a component changes the value of a particular variable,\r\nall other components should get the updated value.\r\n\r\nLet's get deeper into it by the simple example. In of my earlier [blogs](https://namitamalik.github.io/) on [**Services in Angular2**](https://namitamalik.github.io/Services-in-Angular2/), \r\nwe had taken an example of a cinema ticket booking scenario where we had:\r\n\r\n1. `AppComponent` - Parent component of the entire application. Included 2 child components.\r\n2. `BookShowComponent` - Component used to make booking through web application e.g. bookshow.com.\r\n3. `WindowComponent` - Component accessed to make booking through cinema window.\r\n4. `BookingService` - A service accessed by both `WindowComponent` and `BookShowComponent` to get the number of tickets available.\r\n\r\nAbove components were then joined together to make a simple `app`. Using this app a user was able to book movie ticket and after each booking, the available ticket count would get updated.\r\nBut, this small `app` had a serious flaw - `one component would not know that the other component has updated the ticket till a booking request was made`.\r\n\r\nSee below:\r\n\r\n![Services_Blog.gif](https://raw.githubusercontent.com/NamitaMalik/Realtime-Update-in-Angular2/master/assets/Services_Blog.gif)\r\n\r\nDid you notice the following:\r\n\r\n1. Initially, total number of available tickets were 10.\r\n2. On booking a ticket through cinema window, the number of available tickets became 9, while at bookshow.com, number of available tickets was still 10.\r\n3. Similarly, after making a booking through bookshow.com, number of available tickets became 8 as correctly displayed on bookshow.com but cinema window still has the booking count as 9.\r\n\r\nTo avoid such a situation, we need to do something so that both the components show data consistently. But how?\r\n\r\nWell, it would not be wrong if I say, that **Angular2** has bought best of all the worlds together and simple solution to the above problem is **Observables**. We know that \r\n**Observables** are being heavily used in **Angular2** just as **Promises** in **Angular 1.x**. But unlike **Promises**, **Observables** have much bigger role to play. Being \r\nbased on the **Observer Pattern** they involve much more than extracting **success** and **error**. So, let's see some other useful stuff that **Observables** can do for us.\r\n\r\n\r\nIf you look at the [Services in Angular2](https://namitamalik.github.io/Services-in-Angular2/) blog, you will notice that our `booking-service.ts` looks like:\r\n \r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\n@Injectable()\r\nexport class BookingService {\r\n    totalTicketCount:number = 10;\r\n}\r\n```\r\n\r\n... and this is the place where we need to make the most important change i.e. making the `totalTicketCount` a **subject**.\r\n\r\nWell, the above line put up a plethora of questions in front of us so let's try to answer each question one by one:\r\n\r\n####Q. What is Subject?\r\n**Ans:** **Subject** is a class in **RxJS** library. It inherits both **Observable** and **Observer** therefore we can easily say that a **subject** is both **observer** and **observable**.\r\nWe know that **observers** subscribe to an **observable** and if **subject** is both **observer** and **observable** this means that there would be **observers** subscribing to it and \r\nalso it subscribing to some other source. A **subject**  simply broadcasts values pushed to it, to all the **subscribers** subscribing to it. \r\nIn real life, shopkeeper can be taken as an example of a **subject**, a shopkeeper is both buyer and a seller. He buys products from a factory and sells products to his customers.\r\n\r\n####Q. Are there any different implementations of Subject?\r\n**Ans:** There are basically 3 different implementation of **Subject** which provide different functionality and can be used on the basis of different use case:\r\n\r\n1. **ReplaySubject** - Stores all the values that have been pushed. It emits all the items that were emitted by the source, to all the **observers** that **subscribe** to it.\r\n2. **AsyncSubject** - It stores the last value and emits it when the sequence is completed.\r\n3. **BehaviorSubject** - **BehaviorSubject** is similar to **ReplaySubject** but it stores only the last value published. Also another difference that distinguishes it from **AsyncSubject** and **ReplaySubject** is that it takes default value at the time of initialisation.\r\nSo an **observer** subscribing to **BehaviorSubject** would receive a value as soon as it subscribes to it.\r\n   \r\n####Q. Which one out of the 3 implementations, we are going to use?\r\n**Ans:** We are going to use **BehaviorSubject** for our case.\r\n\r\n####Q. Can we see some action now?**\r\n**Ans:** Yes Sure, here we go . . . .\r\n\r\nSo, let's make `totalTicketCount` a **BehaviorSubject** as given below:\r\n\r\n```TypeScript\r\ntotalTicketCount:BehaviorSubject<number> = new BehaviorSubject<number>(10);\r\n```\r\n\r\nAfter making this tweak and importing `BehaviorSubject`, our `booking-service.ts` now looks as:\r\n\r\n```TypeScript\r\nimport { Injectable } from '@angular/core';\r\nimport {BehaviorSubject} from 'rxjs/Rx';\r\n\r\n@Injectable()\r\nexport class BookingService {\r\n   totalTicketCount:BehaviorSubject<number> = new BehaviorSubject<number>(10);\r\n\r\n}\r\n```\r\n\r\nNow, let's make some tweaks in our `book-show.component.ts` and `window.component.ts` and these should be:\r\n\r\n1. We first need to subscribe to our `totalTicketCount` subject so that we can start receiving values from it:\r\n    ```TypeScript\r\n    constructor(private _bookingService:BookingService) {\r\n        this._bookingService.totalTicketCount.subscribe(totalTicketCount => {\r\n            this.ticketCount = totalTicketCount\r\n        });\r\n    }\r\n    ```\r\n\r\n2. Once a user makes a booking we need to update the `totalTicketCount`:\r\n    ```TypeScript\r\n    bookShow = () => {\r\n        let ticketCount = this.ticketCount - 1;\r\n        this._bookingService.totalTicketCount.next(ticketCount);\r\n    }\r\n    ```\r\n\r\nWe have updated the `totalTicketCount` by notifying the `observer` about the next value.\r\n\r\nAfter doing the above tweaks in both `book-show.component.ts` and `window.component.ts`, they would look like:\r\n\r\n**book-show.component.ts**\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {BookingService} from \"../common/service/booking-service\";\r\n\r\n@Component({\r\n    selector: 'book-show',\r\n    template: `\r\n        <div>\r\n            <h1>Welcome to bookshow.com</h1>\r\n            <span>Welcome User</span>\r\n            <p>Currently, Number of Tickets available are: {{ticketCount}}</p>\r\n            <button (click)=\"bookShow()\">Book Ticket</button>\r\n        </div>\r\n    `\r\n})\r\n\r\nexport class BookShowComponent {\r\n    ticketCount:number = 0;\r\n\r\n    constructor(private _bookingService:BookingService) {\r\n        this._bookingService.totalTicketCount.subscribe(totalTicketCount => {\r\n            this.ticketCount = totalTicketCount\r\n        });\r\n    }\r\n\r\n    bookShow = () => {\r\n        let ticketCount = this.ticketCount - 1;\r\n        this._bookingService.totalTicketCount.next(ticketCount);\r\n    }\r\n}\r\n```\r\n\r\n**window.component.ts**\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {BookingService} from \"../common/service/booking-service\";\r\n\r\n@Component({\r\n    selector: 'cinema-window',\r\n    template: `\r\n    <div>\r\n        <h1>ABC Cinemas</h1>\r\n        <span>Hello Admin</span>\r\n        <p>Currently, Number of Tickets available are: {{ticketCount}}</p>\r\n        <button (click)=\"bookTicket()\">Book Ticket</button>\r\n    </div>\r\n    `\r\n})\r\n\r\nexport class WindowComponent {\r\n    ticketCount:number = 0;\r\n\r\n    constructor(private _bookingService:BookingService) {\r\n        this._bookingService.totalTicketCount.subscribe(totalTicketCount => {\r\n            this.ticketCount = totalTicketCount\r\n        });\r\n    }\r\n\r\n    bookTicket = () => {\r\n        this.ticketCount = this.ticketCount - 1;\r\n        this._bookingService.totalTicketCount.next(this.ticketCount);\r\n    };\r\n}\r\n```\r\n\r\nAfter doing the above tweaks, we should now be able to see the available ticket count **real-time** as shown in below:\r\n\r\n![Realtime-Blog.gif](https://raw.githubusercontent.com/NamitaMalik/Realtime-Update-in-Angular2/master/assets/Realtime_Blog.gif)\r\n\r\n> Note: This is a small demo app to show how to make real time client updates. In a real world app, one will have to get the updated data from the server by using things like socket connections(which is not the agenda of this blog).\r\n\r\nFollow Me\r\n---\r\n[Github](https://github.com/NamitaMalik)\r\n\r\n[Twitter](https://twitter.com/namita13_04)\r\n\r\n[LinkedIn](https://in.linkedin.com/in/namita-malik-a7885b23)\r\n\r\n[More Blogs By Me](https://namitamalik.github.io/)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}